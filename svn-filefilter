#!/bin/bash

# Enable extended file pattern matching operators from ksh
# (?(pattern-list), !(pattern-list), ...) in Bash.
shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Filter to grey out / ... files outside PATH / the CWD from the svn verbose log
and to transform diffs and property changes outside PATH to one-line summaries.
--no-color	Turn off coloring.
Usage: svn lc ... | "$(basename "$1")" [--no-color] [PATH...] [-?|-h|--help]
HELPTEXT
}

: ${COLOR_OMITTED:='[37m'}
: ${COLOR_RESET:='[0m'}
isColor=t
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--no-color)	shift; isColor=
			# And clear all colors used here.
			for color in ${!COLOR_@}; do
			    unset $color
			done
			;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done

[ $# -eq 0 ] && set -- "$(svn-pathname)"

typeset -a pathGrepArgs=(-F)
for path
do
    pathGrepArgs+=(-e "${path%/}/")
done



processLog()
{
    [ "$1" ] || return
    local logline
    while IFS=$'\n' read -r logline
    do
	case "$logline" in
	    *( )+([ADMR])+( )/*)
		path=${logline#*( )+([ADMR])+( )/}
		path=${path% (from *)}
		if printf %s "$path" | grep --quiet "${pathGrepArgs[@]}"; then
		    printf '%s\n' "$logline"
		elif [ "$isColor" ]; then
		    printf '%s\n' "${COLOR_OMITTED}${logline}${COLOR_RESET}"
		else
		    printf '   ...\n'
		fi
		;;
	    *) printf '%s\n' "$logline";;
	esac
    done <<< "$1"
}

processContents()
{
    [ "$2" ] || return

    if printf %s "$1" | grep --quiet "${pathGrepArgs[@]}"; then
	printf '%s\n' "$2"
    else
	omitted=${2%%$'\n'*}
	printf '%s\n' "${COLOR_OMITTED}Omitted: ${omitted#Index: }${COLOR_RESET}"
    fi
}

process()
{
    if [ "$1" ]; then
	processContents "$@"
    else
	processLog "$2"
    fi
}

chunkify()
{
    local contents=
    local file=
    local line
    while IFS=$'\n' read -r line
    do
	case "$line" in
	    revision\ *)
		process "$file" "$contents"

		contents=$line # Start anew.
		file=
		;;
	    Index:\ *)
		process "$file" "$contents"

		contents=$line # Start anew.
		file=${line#Index: }
		;;
	    Property\ changes\ on:\ *)
		if [ "$file" = "${line#Property changes on: }" ]; then
		    # Still belongs to the same file.
		    contents="$contents
$line"
		else
		    process "$file" "$contents"

		    contents=$line # Start anew.
		    file=${line#Property changes on: }
		fi
		;;
	    *)
		contents="$contents
$line"
	    ;;
	esac
    done

    # Process the very last contents, too.
    process "$file" "$contents"
}

chunkify | less --quit-on-intr --RAW-CONTROL-CHARS
