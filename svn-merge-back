#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Find merge candidates in SOURCE that still needs merging into the working copy,
and merge them back.
Usage: "$(basename "$1")" [-v|--verbose] [--grep REGEXP [--grep ...]] [-i|--regexp-ignore-case] [-E|--extended-regexp|-F|--fixed-strings] [--author REGEXP] [-c M | -r N[:M]] [-l|--limit ARG] SOURCE[@REV] [-?|-h|--help]
HELPTEXT
}

typeset -a allargs=()
isRevisionGiven=
while [ $# -gt 1 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	*)
	    allargs+=("$1")
	    case "$1" in
		--change|-c)	isRevisionGiven=t;;
		--revision|-r)	isRevisionGiven=t;;
	    esac
	    shift
	    ;;
    esac
done
[ $# -eq 0 ] && { printUsage "$0"; exit 2; }
source=$1

IFS=$'\n'

if [ "$isRevisionGiven" ]; then
    echo >&2 "Considering passed revision(s)."
    typeset -a candidateRevisions=()
else
    typeset -a candidateRevisions=($(svn mergeinfo --non-interactive --show-revs eligible "$source"))
    if [ ${#candidateRevisions[@]} -eq 0 ]; then
	echo >&2 "No merge candidates found"
	exit 1
    fi

    printf >&2 'Considering %d revision(s).\n' "${#candidateRevisions[@]}"
fi


typeset -a mergeRevisions=($(svn-log --format revisionsonly "${allargs[@]}" ${candidateRevisions[*]/r/-c } "$source"))
if [ ${#mergeRevisions[@]} -le 0 ]; then
    echo >&2 "No revisions to merge."
    exit 1
fi
svn-wrapper merge --non-interactive ${mergeRevisions[*]/r/-c } "$source" || exit $?


relativeSource=$(svn info --non-interactive "$source" | sed -ne 's/^Relative URL: //p') || relativeSource=$source
commitMessage=svn-commit.tmp
if [ ${#mergeRevisions[@]} -eq 1 ]; then
    printf 'Merged %s from %s:\n' "${mergeRevisions[0]}" "$relativeSource"
    svn-log --format noheader "${allargs[@]}" ${mergeRevisions[*]/r/-c } "$source"
else
    IFS=','
    mergeRevisionsList="${mergeRevisions[*]/r/ r}"
    printf 'Merged revisions %s from %s:\n' "${mergeRevisionsList# }" "$relativeSource"
    svn-log --format merge "${allargs[@]}" ${mergeRevisions[*]/r/-c } "$source"
fi > "$commitMessage"
