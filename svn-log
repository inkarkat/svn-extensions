#!/bin/bash

shopt -qs extglob 2>/dev/null

printUsage()
{
    cat <<HELPTEXT
Verbose log messages. 
-v		Include a list of changed files. 
--grep regexp   Limit the commits to ones with log message that matches the
		specified pattern. 
--author regexp	Limit to commits by author. 
--no-merge	Exclude any commits that mention merge in the revision summary. 
--server	Instead of local history, only list server revisions that you
		don't have yet. 
Usage: "$(basename "$1")" [--no-merge] [-v|--verbose] [--grep regexp] [--author regexp] [-c M | -r N[:M]] [-l|--limit ARG] [--server|PATH...] [-?|-h|--help]
HELPTEXT
}

mergeFilter()
{
    sed --unbuffered -e '
# Silently capture all header lines until the revision summary in hold space. 
/^revision r[0-9]\+$/ {
    h	# This starts the header. 
    d
}
/^Author:/ {
    H
    d
}
/^Date:/ {
    N		# Following line is empty. 
    H		# Last header line to capture in hold space. 
    s/.*//	# Clear without printing.  
    N		# Inspect revision summary. 
    s/^\n//	# Undo effect of N; n cannot be used because it would print empty line. 
    /[Mm]erg\(e\|ed\|es\|ing\)\b/ {
	# Push special MERGE marker into hold space. 
	s/.*/MERGE/
	h
	d
    }
    # If the revision summary did not mention a merge, we continue in the script
    # with the header in hold space. 
}

x   # Inspect hold space. 
/MERGE/ {
    # Currently in merge revision, discard current line. 
    x
    d
}

# Not in merge revision; print header from hold space once.  
/^$/!p
s/.*//

# And print log line, too. 
x
'
}

extractHeaderItem()
{
    sed -ne "s/^${1}: \\+//p" "$2"
}
extractRevisionMessage()
{
    sed -e '
/^revision r[0-9]\+$/d
/^Author:/d
/^Date:/d
/^Changed paths:/,/^revision r[0-9]\+$/d
' "$1"
}
showNoMatch()
{
    # Going through the revision history (and the processing on Cygwin) takes
    # some time... Print a temporary status to stderr that overwrites itself as
    # the processing progresses. 
    # Note: Print trailing space to clear previous status when the number of
    # digits in the revision decreases. 
    [ "$1" ] && printf >&2 '%s\r' "${1} "
}
processRevision()
{
    local -r FILE=${1:?}
    isSkip=

    if [ "$authorArgs" ]; then
	extractHeaderItem 'Author' "$FILE" | grep -q "$authorArgs" || isSkip='true'
    fi
    if [ "$grepArgs" ]; then
	# Filter away the revision header and changed file list, and
	# try to match the regexp in the remaining revision message. 
	extractRevisionMessage "$FILE" | grep -q "$grepArgs" || isSkip='true'
    fi

    if [ "$isSkip" ]; then
	showNoMatch "$revision"
    else 
	if [ "$grepArgs" -a "$grepOptions" ]; then
	    # Let (another pass of) grep highlight the matches. 
	    # We include all lines (but without highlighting) with
	    # the regexp /$/. 
	    grep $grepOptions -e "$grepArgs" -e '$' "$FILE"
	else
	    cat "$FILE"
	fi | colorize
	# Must do fine-grained colorization here so that the results
	# appear immediately, to avoid buffering in the pipe. 
    fi
}
grepFilter()
{
    TMPFILE=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$")

    revision=
    while IFS='
' read -r line
    do
	case "$line" in
	    revision\ r+([0-9]))
		if [ -r "$TMPFILE" ]; then
		    processRevision "$TMPFILE"
		fi

		revision=$line
		# Start a new temporary revision file. 
		echo "$line" > "$TMPFILE"
		;;
	    *)
		echo "$line" >> "$TMPFILE"
		;;
	esac
    done
    
    # Process the very last revision, too. 
    if [ -r "$TMPFILE" ]; then
	processRevision "$TMPFILE"
    fi

    rm "$TMPFILE" 2>/dev/null
}

: ${COLOR_HEADER:='[36m'}
: ${COLOR_FILEADDED:='[32m'}
: ${COLOR_FILECHANGED:='[34m'}
: ${COLOR_FILEREMOVED:='[31m'}
: ${COLOR_RESET:='[0m'}
colorize()
{
    sed --unbuffered --unbuffered -e "
s/^revision r[0-9]\\+$/${COLOR_HEADER}\\0${COLOR_RESET}/
/^Changed paths:/,/^\$/ {
    s/^ \\+A .*\$/${COLOR_FILEADDED}\\0${COLOR_RESET}/
    s/^ \\+M .*\$/${COLOR_FILECHANGED}\\0${COLOR_RESET}/
    s/^ \\+R .*\$/${COLOR_FILEREMOVED}\\0${COLOR_RESET}/
}
"
}

mergeFilter=cat
finalFilter=colorize
grepArgs=
grepOptions=
case "$GREP_OPTIONS" in
    # The user prefers highlighting of grep matches; enable this in here, too,
    # even though our grep is in a pipe. 
    *--color=auto*) grepOptions='--color=always';;
    *--color=always*) grepOptions='--color=always';;
esac
authorArgs=
isServerRevisions=

typeset -a allargs=()
while [ $# -gt 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--no-merge)	shift; mergeFilter='mergeFilter';;
	--grep)		shift; finalFilter='grepFilter'; grepArgs=$1; shift;;
	--author)	shift; finalFilter='grepFilter'; authorArgs=$1; shift;;
	--server)	shift; isServerRevisions='true';;
	*)
	    allargs+=("$1")
	    shift
	    ;;
    esac
done
if [ "$isServerRevisions" ]; then
    allargs+=($(svn-serverrevs))
fi

svn log --non-interactive "${allargs[@]}" | sed --unbuffered -e '
/^r[0-9]\+/{
    # Expand revision info into multi-line header. 
    s/\(^r[0-9]\+\) *| *\([^|]\+\) *| *\([^|]\+\) *|.*/revision \1\nAuthor: \2\nDate:   \3 /
    b
}
# Silently capture the changed file list in hold space. 
/^Changed paths:/,/^$/ {
    /^Changed paths:/{
	# Because this range consumes the empty line between the changed file
	# list and the revision summary, it must be printed explicitly to
	# maintain the spacing towards the header. 
	a\

	s/^/\n/	# Also start the stored block with a newline. 
	# This starts the changed file list. 
	h
	d
    }
    H
    d
}

# At the end of the revision log, print the changed file list (in case of "svn
# log -v"). 
/^-\+$/{ g; b }

# Indent revision message. 
s/^/    /
' | $mergeFilter | $finalFilter | less --quit-on-intr --RAW-CONTROL-CHARS
