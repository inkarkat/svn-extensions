#!/bin/bash

set -o pipefail

readonly passedRevision=${1:?}; shift
readonly committedFile=$1; shift
repoRoot=$(svn-root "$(dirname "$committedFile")") || echo >&2 "Warning: Cannot determine the repository's root from $committedFile"
#****D echo "**** post-commit hook for $passedRevision on $committedFile"



extractDefectId()
{
    defectId=$(printf %s "$summary" | sed -e 's/^.*\(QCCR[0-9A-Z]\+\).*$/\1/')
}
getAdditionalInformation()
{
    readonly branchFullName=$(svn-branchname "$repoRoot")
    readonly branchName=${branchFullName##*/}

    eval "$(svn info --non-interactive -r "$passedRevision" "$repoRoot" | svn-parse-info)"

    readonly RepositoryName=${RepositoryRoot##*/}
    nonDefaultRepository=
    if [ "$RepositoryName" != "$repository" ]; then
	nonDefaultRepository="${RepositoryName}'s "
    fi

    case "$repository" in
	hpsw-opr)		defaultAffected=opr-web.war;;
	hpsw-opr-config)	defaultAffected=opr-config-server.war;;
	*)			defaultAffected=;;
    esac

    readonly fixedVersion=$(opr-version --server -r "$passedRevision" "$repoRoot")
}

searchForPreviousMentions()
{
    hasPreviousMentions=
    revisions=$revision
    typeset -a descriptions=$description
    printf >&2 '\n**** Searching for previous mentions of %s in the summary...\n' "$1"
    while read -r logLine
    do
	logRevision=${logLine%% *}
	[ "${logRevision#r}" = "${revision#r}" ] && continue
	echo "**** $logRevision"
	hasPreviousMentions=t
	eval "$(svn log --non-interactive -v -r "$logRevision" "$repoRoot" | svn-parse-logentry)"
	revisions="${logRevision}, $revisions"
	descriptions=("${description[@]}" "" "${descriptions[@]}")
	IFS=$'\n' cat <<EOF
SOLUTION:
${description[*]}

EOF
    done < <((svn-lg --no-color --server "$repoRoot"; svn-lg --no-color "$repoRoot") | GREP_OPTIONS= grep -F "$1")

    # Remove duplicate description lines; keep the first one (from the oldest
    # commit). Later commits often just append to the description. Keep (single)
    # empty lines to maintain the structure.
    local IFS=$'\n'
    typeset -a uniqueDescriptions=$(printf '%s\n' "${descriptions[*]}" | awk -e '/^$/{print}' -e '!x[$0]++' | cat -s)

    if [ "$hasPreviousMentions" ]; then
	echo "**** combined $defectId"
	IFS=$'\n' output <<EOF
TECHNICAL PROBLEM DESCRIPTION:
[Missing|Faulty] implementation.

SOLUTION:
${uniqueDescriptions[*]}

MODIFIED FILES (repository, branch and revision; per release):
$revisions on ${nonDefaultRepository}$branchName

AFFECTED PROGRAMS/SCRIPTS/LIBRARIES:
$defaultAffected

DOCUMENTATION CHANGE:

FIXED FOR VERSION:
$fixedVersion
EOF
    else
	echo "**** none found."
    fi
}

output()
{
    if type -t clipboard >/dev/null; then
	tee >(clipboard)
    else
	cat
    fi
}

parsedLogEntry="$(svn log --non-interactive -v -r "$passedRevision" "$repoRoot" | svn-parse-logentry)" || exit $?
eval "$parsedLogEntry"

case "$summary" in
    Merge\ of\ QCCR*)
	extractDefectId
echo "**** Merge of $defectId"
	getAdditionalInformation

	output <<EOF
MODIFIED FILES (repository, branch and revision; per release):
$revision on ${nonDefaultRepository}$branchName

FIXED FOR VERSION:
$fixedVersion
EOF
	;;
    *QCCR*)
	extractDefectId
echo "**** $defectId"
	getAdditionalInformation

	IFS=$'\n' output <<EOF
TECHNICAL PROBLEM DESCRIPTION:
[Requirement ill-considered|Technology weakness|Faulty design|Missing implementation|Faulty implementation|Inconsistency caused by duplication|Oversight|Negligence].

SOLUTION:
${description[*]}

MODIFIED FILES (repository, branch and revision; per release):
$revision on ${nonDefaultRepository}$branchName

AFFECTED PROGRAMS/SCRIPTS/LIBRARIES:
$defaultAffected

DOCUMENTATION CHANGE:

FIXED FOR VERSION:
$fixedVersion
EOF
	searchForPreviousMentions "$defectId"
	;;
    *)
echo "**** This is no CR."
	readonly branchFullName=$(svn-branchname "$repoRoot")
	typeset -a files=("${paths[@]#/${branchFullName}/}")
	readonly fileNum=${#files[@]}
	[ $fileNum -eq 1 ] && readonly filePlural= || filePlural=s
	output <<EOF
$summary

${description[*]}
EOF
echo "**** Committed $fileNum file${filePlural} below $(commonpath "${files[@]}")."
	;;
esac
