#!/bin/bash

set -o pipefail
[ -t 2 ] && readonly isStderrToTerminal=t || readonly isStderrToTerminal=

: ${SVN_COMMIT_MENTIONS_SEARCH_LIMIT=500}   # Maximum number of commits to search for previous mentions.

passedRevision=${1:?}; shift
readonly committedFile=$1; shift
mainRepoRoot=$(svn-root "$(dirname "$committedFile")") || echo >&2 "Warning: Cannot determine the repository's root from $committedFile"
#****D echo "**** post-commit hook for $passedRevision on $committedFile"



extractTaskId()
{
    taskId=$(printf %s "$summary" | sed -e 's/^\(QCRQ[0-9A-Z]\+\).*$/\1/')
}
extractDefectId()
{
    defectId=$(printf %s "$summary" | sed -e 's/^\(Merge of \)\?\(QCCR[0-9A-Z]\+\)\(: .*\)\?$/\2/' -e t -e 's/\(QCCR[0-9A-Z]\+\).*$/\1/' -e 's/^.*\(QCCR[0-9A-Z]\+\)/\1/')
}
getRepoInformation()
{
    repoRoot=${1:?}
    branchFullName=$(svn-branchname "$repoRoot")
    branchName=${branchFullName##*/}

    eval "$(svn info --non-interactive ${passedRevision:+-r "$passedRevision"} "$repoRoot" | svn-parse-info)"

    RepositoryName=${RepositoryRoot##*/}
    nonDefaultRepository=
    if [ "$RepositoryName" != "$repository" ]; then
	nonDefaultRepository="${RepositoryName}'s "
    fi

}
getFullRepoInformation()
{
    repoRoot=${1:?}
    getRepoInformation "$repoRoot"
    case "$repository" in
	hpsw-opr-core)		defaultAffected=opr-web.war;;
	hpsw-opr-config)	defaultAffected=opr-config-server.war;;
	*)			defaultAffected=;;
    esac

    readonly fixedVersion=$(opr-version --server ${passedRevision:+-r "$passedRevision"} "$repoRoot")
}
getInterestingCommitSummary()
{
    if [ "${summary#${defectId}: }" == "$summary" ]; then
	# The summary does not start with the defect ID; it's interesting, but
	# omit the defect ID itself.
	printf '%s\n ' "${summary/${defectId}: /}"
    fi
}

typeset -a modifiedFiles
searchForPreviousMentions()
{
    repoRoot=${1:?}
    defectId=${2:?}
    hasPreviousMentions=
    laterSummary=$summary
    revisions=$revision
    [ "$isStderrToTerminal" ] && printf >&2 "\\n**** Searching pending and ${SVN_COMMIT_MENTIONS_SEARCH_LIMIT:+last }${SVN_COMMIT_MENTIONS_SEARCH_LIMIT:-past} commits in ${RepositoryName} for previous mentions of %s in the summary...\\n" "$defectId"
    while read -r logLine
    do
	logRevision=${logLine%% *}
	[ "${logRevision#r}" = "${revision#r}" ] && continue
	echo "**** $logRevision"
	if [ ! "$hasPreviousMentions" ]; then
	    descriptions+=("(r${revision#r})")
	fi
	hasPreviousMentions=t
	eval "$(svn log --non-interactive -v -r "$logRevision" "$repoRoot" | svn-parse-logentry)"
	revisions="${logRevision}${revisions:+, $revisions}"

	if [ "$laterSummary" -a "${laterSummary#${summary}}" = "$laterSummary" ]; then
	    # Summary is different from the later commit's and has not just been
	    # appended to. Include it; it may provide necessary context for the
	    # long description.
	    descriptions=("${laterSummary/${defectId}: /}" "${descriptions[@]}")
	fi
	laterSummary=$summary

	if [ ${#description[@]} -gt 0 ]; then
	    descriptions=("${description[@]}" "(r${logRevision#r})" "" "${descriptions[@]}")
	fi

	local interestingCommitSummary=$(getInterestingCommitSummary)
	if [ "$interestingCommitSummary" ]; then
	    descriptions=("${interestingCommitSummary% }" "${descriptions[@]}")
	    laterSummary=
	fi

	IFS=$'\n' cat <<EOF
SOLUTION:
${interestingCommitSummary% }${description[*]}

EOF
    done < <((svn-lg --non-interactive --no-color --no-list-author --no-list-date --server "$repoRoot"; svn-lg --non-interactive --no-color --no-list-author --no-list-date ${SVN_COMMIT_MENTIONS_SEARCH_LIMIT:+--limit "$SVN_COMMIT_MENTIONS_SEARCH_LIMIT"} "$repoRoot") | GREP_OPTIONS= grep "^r[0-9]\+ \([^[:space:]]\+: \)*${defectId}: ")

    # Remove duplicate description lines; keep the first one (from the oldest
    # commit). Later commits often just append to the description. Keep (single)
    # empty lines to maintain the structure.
    local IFS=$'\n'
    typeset uniqueDescriptions=$(printf '%s\n' "${descriptions[*]}" | awk -e '/^$/{print}' -e '!x[$0]++' | cat -s)
    modifiedFiles+=("$revisions on ${nonDefaultRepository}$branchName")

    if [ "$hasPreviousMentions" ]; then
	echo "**** combined $defectId"
	IFS=$'\n' output <<EOF
TECHNICAL PROBLEM DESCRIPTION:
$problemDescription

SOLUTION:
${uniqueDescriptions}

MODIFIED FILES (repository, branch and revision; per release):
${modifiedFiles[*]}

AFFECTED PROGRAMS/SCRIPTS/LIBRARIES:
$defaultAffected

DOCUMENTATION CHANGE:

FIXED FOR VERSION:
$fixedVersion
EOF
    else
	echo "**** none found."
    fi
}

output()
{
    if type -t clipboard >/dev/null; then
	tee >(clipboard)
    else
	cat
    fi
}

searchAllReposForPreviousMentions()
{
    typeset -a descriptions=("${description[@]}")
    searchForPreviousMentions "$mainRepoRoot" "$defectId"

    # I would have preferred Bash's associative arrays, but these cannot be
    # exported.
    currentRepoRoot=$(svn-root 2>/dev/null || printf %s "$mainRepoRoot")
    readonly otherRepoConfig="${currentRepoRoot}/.svn/commit-mentions-repo-paths"
    [ -r "$otherRepoConfig" ] || return 0

    while IFS=$'\n' read -r otherRepoRoot
    do
	case "$otherRepoRoot" in
	    \#*|'')		continue;;
	    "$mainRepoRoot")	continue;;
	esac

	# These are only applicable to the main repository; clear them.
	revision=
	passedRevision=

	getRepoInformation "$otherRepoRoot"
	searchForPreviousMentions "$otherRepoRoot" "$defectId"
    done < "$otherRepoConfig"
}

parsedLogEntry="$(svn log --non-interactive -v ${passedRevision:+-r "$passedRevision"} "$mainRepoRoot" | svn-parse-logentry)" || exit $?
eval "$parsedLogEntry"

case "$summary" in
    Merge\ of\ QCCR*)
	extractDefectId
echo "**** Merge of $defectId"
	getFullRepoInformation "$mainRepoRoot"

	output <<EOF
MODIFIED FILES (repository, branch and revision; per release):
$revision on ${nonDefaultRepository}$branchName

FIXED FOR VERSION:
$fixedVersion
EOF
	;;
    *QCCR*)
	extractDefectId
echo "**** $defectId"
	getFullRepoInformation "$mainRepoRoot"

	problemDescription=$(sed -n -e '/^TECHNICAL PROBLEM DESCRIPTION/{ N; s/^[^\n]*\n//; p }' ~/.vim/templates/cr_resolution.txt)
	interestingCommitSummary=$(getInterestingCommitSummary)
	IFS=$'\n' output <<EOF
TECHNICAL PROBLEM DESCRIPTION:
$problemDescription

SOLUTION:
${interestingCommitSummary% }${description[*]}

MODIFIED FILES (repository, branch and revision; per release):
$revision on ${nonDefaultRepository}$branchName

AFFECTED PROGRAMS/SCRIPTS/LIBRARIES:
$defaultAffected

DOCUMENTATION CHANGE:

FIXED FOR VERSION:
$fixedVersion
EOF
	searchAllReposForPreviousMentions
	;;
    QCRQ*)
	extractTaskId
echo "**** This is task $taskId"
	output <<EOF
${revision}: ${summary#$taskId: }
EOF
	;;
    *)
echo "**** This is no CR."
	readonly branchFullName=$(svn-branchname "$mainRepoRoot")
	typeset -a files=("${paths[@]#/${branchFullName}/}")
	readonly fileNum=${#files[@]}
	[ $fileNum -eq 1 ] && readonly filePlural= || filePlural=s
	output <<EOF
$summary

${description[*]}
EOF
	echo "**** Committed $fileNum file${filePlural} below $(commonpath "${files[@]}")."
	;;
esac
